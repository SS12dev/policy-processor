================================================================================
DEEP A2A SDK EXPLORATION
================================================================================

================================================================================
MODULE: a2a.client
================================================================================

CLASSES (16)
--------------------------------------------------------------------------------

  [A2ACardResolver]
     Agent Card resolver.
     Constructor: __init__(self, httpx_client: httpx.AsyncClient, base_url: str, agent_card_path: str = '/.well-known/agent-card.json') -> None
     Methods (2):
       - __init__(self, httpx_client: httpx.AsyncClient, base_url: str, agent_card_path: str = '/.well-known/agent-card.json') -> None
         > Initializes the A2ACardResolver.  Args:     httpx_client: An async HTTP client instance (e.g., httpx.AsyncClient).     base_url: The base URL of the a
       - [async] get_agent_card(self, relative_card_path: str | None = None, http_kwargs: dict[str, typing.Any] | None = None) -> a2a.types.AgentCard
         > Fetches an agent card from a specified path relative to the base_url.  If relative_card_path is None, it defaults to the resolver's configured agent_c

  [A2AClient]
     [DEPRECATED] Backwards compatibility wrapper for the JSON-RPC client.
     Constructor: __init__(self, httpx_client: httpx.AsyncClient, agent_card: a2a.types.AgentCard | None = None, url: str | None = None, interceptors: list[a2a.client.middleware.ClientCallInterceptor] | None = None)
     Methods (9):
       - __init__(self, httpx_client: httpx.AsyncClient, agent_card: a2a.types.AgentCard | None = None, url: str | None = None, interceptors: list[a2a.client.middleware.ClientCallInterceptor] | None = None)
         > Initialize self.  See help(type(self)) for accurate signature.
       - [async] cancel_task(self, request: a2a.types.CancelTaskRequest, *, http_kwargs: dict[str, typing.Any] | None = None, context: a2a.client.middleware.ClientCallContext | None = None) -> a2a.types.CancelTaskResponse
         > Requests the agent to cancel a specific task.  Args:     request: The `CancelTaskRequest` object specifying the task ID.     http_kwargs: Optional dic
       - [async] get_card(self, *, http_kwargs: dict[str, typing.Any] | None = None, context: a2a.client.middleware.ClientCallContext | None = None) -> a2a.types.AgentCard
         > Retrieves the authenticated card (if necessary) or the public one.  Args:     http_kwargs: Optional dictionary of keyword arguments to pass to the    
       - [async] get_task(self, request: a2a.types.GetTaskRequest, *, http_kwargs: dict[str, typing.Any] | None = None, context: a2a.client.middleware.ClientCallContext | None = None) -> a2a.types.GetTaskResponse
         > Retrieves the current state and history of a specific task.  Args:     request: The `GetTaskRequest` object specifying the task ID and history length.
       - [async] get_task_callback(self, request: a2a.types.GetTaskPushNotificationConfigRequest, *, http_kwargs: dict[str, typing.Any] | None = None, context: a2a.client.middleware.ClientCallContext | None = None) -> a2a.types.GetTaskPushNotificationConfigResponse
         > Retrieves the push notification configuration for a specific task.  Args:     request: The `GetTaskPushNotificationConfigRequest` object specifying th
       - resubscribe(self, request: a2a.types.TaskResubscriptionRequest, *, http_kwargs: dict[str, typing.Any] | None = None, context: a2a.client.middleware.ClientCallContext | None = None) -> collections.abc.AsyncGenerator[a2a.types.SendStreamingMessageResponse, None]
         > Reconnects to get task updates.  This method uses Server-Sent Events (SSE) to receive a stream of updates from the agent.  Args:     request: The `Tas
       - [async] send_message(self, request: a2a.types.SendMessageRequest, *, http_kwargs: dict[str, typing.Any] | None = None, context: a2a.client.middleware.ClientCallContext | None = None) -> a2a.types.SendMessageResponse
         > Sends a non-streaming message request to the agent.  Args:     request: The `SendMessageRequest` object containing the message and configuration.     
       - send_message_streaming(self, request: a2a.types.SendStreamingMessageRequest, *, http_kwargs: dict[str, typing.Any] | None = None, context: a2a.client.middleware.ClientCallContext | None = None) -> collections.abc.AsyncGenerator[a2a.types.SendStreamingMessageResponse, None]
         > Sends a streaming message request to the agent and yields responses as they arrive.  This method uses Server-Sent Events (SSE) to receive a stream of 
       - [async] set_task_callback(self, request: a2a.types.SetTaskPushNotificationConfigRequest, *, http_kwargs: dict[str, typing.Any] | None = None, context: a2a.client.middleware.ClientCallContext | None = None) -> a2a.types.SetTaskPushNotificationConfigResponse
         > Sets or updates the push notification configuration for a specific task.  Args:     request: The `SetTaskPushNotificationConfigRequest` object specify

  [A2AClientError]
     Inherits from: Exception
     Base exception for A2A Client errors.
     Constructor: __init__(self, /, *args, **kwargs)
     Attributes (1):
       - args: getset_descriptor

  [A2AClientHTTPError]
     Inherits from: A2AClientError
     Client exception for HTTP errors received from the server.
     Constructor: __init__(self, status_code: int, message: str)
     Methods (1):
       - __init__(self, status_code: int, message: str)
         > Initializes the A2AClientHTTPError.  Args:     status_code: The HTTP status code of the response.     message: A descriptive error message.
     Attributes (1):
       - args: getset_descriptor

  [A2AClientJSONError]
     Inherits from: A2AClientError
     Client exception for JSON errors during response parsing or validation.
     Constructor: __init__(self, message: str)
     Methods (1):
       - __init__(self, message: str)
         > Initializes the A2AClientJSONError.  Args:     message: A descriptive error message.
     Attributes (1):
       - args: getset_descriptor

  [A2AClientTimeoutError]
     Inherits from: A2AClientError
     Client exception for timeout errors during a request.
     Constructor: __init__(self, message: str)
     Methods (1):
       - __init__(self, message: str)
         > Initializes the A2AClientTimeoutError.  Args:     message: A descriptive error message.
     Attributes (1):
       - args: getset_descriptor

  [A2AGrpcClient]
     Placeholder for A2AGrpcClient when dependencies are not installed.
     Constructor: __init__(self, *args, **kwargs)
     Methods (1):
       - __init__(self, *args, **kwargs)
         > Initialize self.  See help(type(self)) for accurate signature.

  [AuthInterceptor]
     Inherits from: ClientCallInterceptor
     An interceptor that automatically adds authentication details to requests.
     Based on the agent's security schemes.
     Constructor: __init__(self, credential_service: a2a.client.auth.credentials.CredentialService)
     Methods (2):
       - __init__(self, credential_service: a2a.client.auth.credentials.CredentialService)
         > Initialize self.  See help(type(self)) for accurate signature.
       - [async] intercept(self, method_name: str, request_payload: dict[str, typing.Any], http_kwargs: dict[str, typing.Any], agent_card: a2a.types.AgentCard | None, context: a2a.client.middleware.ClientCallContext | None) -> tuple[dict[str, typing.Any], dict[str, typing.Any]]
         > Applies authentication headers to the request if credentials are available.

  [BaseClient]
     Inherits from: Client
     Base implementation of the A2A client, containing transport-independent logic.
     Constructor: __init__(self, card: a2a.types.AgentCard, config: a2a.client.client.ClientConfig, transport: a2a.client.transports.base.ClientTransport, consumers: list[collections.abc.Callable[[tuple[a2a.types.Task, a2a.types.TaskStatusUpdateEvent | a2a.types.TaskArtifactUpdateEvent | None] | a2a.types.Message, a2a.types.AgentCard], collections.abc.Coroutine[None, typing.Any, typing.Any]]], middleware: list[a2a.client.middleware.ClientCallInterceptor])
     Methods (12):
       - __init__(self, card: a2a.types.AgentCard, config: a2a.client.client.ClientConfig, transport: a2a.client.transports.base.ClientTransport, consumers: list[collections.abc.Callable[[tuple[a2a.types.Task, a2a.types.TaskStatusUpdateEvent | a2a.types.TaskArtifactUpdateEvent | None] | a2a.types.Message, a2a.types.AgentCard], collections.abc.Coroutine[None, typing.Any, typing.Any]]], middleware: list[a2a.client.middleware.ClientCallInterceptor])
         > Initializes the client with consumers and middleware.  Args:     consumers: A list of callables to process events from the agent.     middleware: A li
       - [async] add_event_consumer(self, consumer: collections.abc.Callable[[tuple[a2a.types.Task, a2a.types.TaskStatusUpdateEvent | a2a.types.TaskArtifactUpdateEvent | None] | a2a.types.Message, a2a.types.AgentCard], collections.abc.Coroutine[None, typing.Any, typing.Any]]) -> None
         > Attaches additional consumers to the `Client`.
       - [async] add_request_middleware(self, middleware: a2a.client.middleware.ClientCallInterceptor) -> None
         > Attaches additional middleware to the `Client`.
       - [async] cancel_task(self, request: a2a.types.TaskIdParams, *, context: a2a.client.middleware.ClientCallContext | None = None, extensions: list[str] | None = None) -> a2a.types.Task
         > Requests the agent to cancel a specific task.  Args:     request: The `TaskIdParams` object specifying the task ID.     context: The client call conte
       - [async] close(self) -> None
         > Closes the underlying transport.
       - [async] consume(self, event: tuple[a2a.types.Task, a2a.types.TaskStatusUpdateEvent | a2a.types.TaskArtifactUpdateEvent | None] | a2a.types.Message | None, card: a2a.types.AgentCard) -> None
         > Processes the event via all the registered `Consumer`s.
       - [async] get_card(self, *, context: a2a.client.middleware.ClientCallContext | None = None, extensions: list[str] | None = None) -> a2a.types.AgentCard
         > Retrieves the agent's card.  This will fetch the authenticated card if necessary and update the client's internal state with the new card.  Args:     
       - [async] get_task(self, request: a2a.types.TaskQueryParams, *, context: a2a.client.middleware.ClientCallContext | None = None, extensions: list[str] | None = None) -> a2a.types.Task
         > Retrieves the current state and history of a specific task.  Args:     request: The `TaskQueryParams` object specifying the task ID.     context: The 
       - [async] get_task_callback(self, request: a2a.types.GetTaskPushNotificationConfigParams, *, context: a2a.client.middleware.ClientCallContext | None = None, extensions: list[str] | None = None) -> a2a.types.TaskPushNotificationConfig
         > Retrieves the push notification configuration for a specific task.  Args:     request: The `GetTaskPushNotificationConfigParams` object specifying the
       - resubscribe(self, request: a2a.types.TaskIdParams, *, context: a2a.client.middleware.ClientCallContext | None = None, extensions: list[str] | None = None) -> collections.abc.AsyncIterator[tuple[a2a.types.Task, a2a.types.TaskStatusUpdateEvent | a2a.types.TaskArtifactUpdateEvent | None]]
         > Resubscribes to a task's event stream.  This is only available if both the client and server support streaming.  Args:     request: Parameters to iden
       - send_message(self, request: a2a.types.Message, *, configuration: a2a.types.MessageSendConfiguration | None = None, context: a2a.client.middleware.ClientCallContext | None = None, request_metadata: dict[str, typing.Any] | None = None, extensions: list[str] | None = None) -> collections.abc.AsyncIterator[tuple[a2a.types.Task, a2a.types.TaskStatusUpdateEvent | a2a.types.TaskArtifactUpdateEvent | None] | a2a.types.Message]
         > Sends a message to the agent.  This method handles both streaming and non-streaming (polling) interactions based on the client configuration and agent
       - [async] set_task_callback(self, request: a2a.types.TaskPushNotificationConfig, *, context: a2a.client.middleware.ClientCallContext | None = None, extensions: list[str] | None = None) -> a2a.types.TaskPushNotificationConfig
         > Sets or updates the push notification configuration for a specific task.  Args:     request: The `TaskPushNotificationConfig` object with the new conf

  [Client]
     Inherits from: ABC
     Abstract base class defining the interface for an A2A client.
     This class provides a standard set of methods for interacting with an A2A
     Constructor: __init__(self, consumers: list[collections.abc.Callable[[tuple[a2a.types.Task, a2a.types.TaskStatusUpdateEvent | a2a.types.TaskArtifactUpdateEvent | None] | a2a.types.Message, a2a.types.AgentCard], collections.abc.Coroutine[None, typing.Any, typing.Any]]] | None = None, middleware: list[a2a.client.middleware.ClientCallInterceptor] | None = None)
     Methods (11):
       - __init__(self, consumers: list[collections.abc.Callable[[tuple[a2a.types.Task, a2a.types.TaskStatusUpdateEvent | a2a.types.TaskArtifactUpdateEvent | None] | a2a.types.Message, a2a.types.AgentCard], collections.abc.Coroutine[None, typing.Any, typing.Any]]] | None = None, middleware: list[a2a.client.middleware.ClientCallInterceptor] | None = None)
         > Initializes the client with consumers and middleware.  Args:     consumers: A list of callables to process events from the agent.     middleware: A li
       - [async] add_event_consumer(self, consumer: collections.abc.Callable[[tuple[a2a.types.Task, a2a.types.TaskStatusUpdateEvent | a2a.types.TaskArtifactUpdateEvent | None] | a2a.types.Message, a2a.types.AgentCard], collections.abc.Coroutine[None, typing.Any, typing.Any]]) -> None
         > Attaches additional consumers to the `Client`.
       - [async] add_request_middleware(self, middleware: a2a.client.middleware.ClientCallInterceptor) -> None
         > Attaches additional middleware to the `Client`.
       - [async] cancel_task(self, request: a2a.types.TaskIdParams, *, context: a2a.client.middleware.ClientCallContext | None = None, extensions: list[str] | None = None) -> a2a.types.Task
         > Requests the agent to cancel a specific task.
       - [async] consume(self, event: tuple[a2a.types.Task, a2a.types.TaskStatusUpdateEvent | a2a.types.TaskArtifactUpdateEvent | None] | a2a.types.Message | None, card: a2a.types.AgentCard) -> None
         > Processes the event via all the registered `Consumer`s.
       - [async] get_card(self, *, context: a2a.client.middleware.ClientCallContext | None = None, extensions: list[str] | None = None) -> a2a.types.AgentCard
         > Retrieves the agent's card.
       - [async] get_task(self, request: a2a.types.TaskQueryParams, *, context: a2a.client.middleware.ClientCallContext | None = None, extensions: list[str] | None = None) -> a2a.types.Task
         > Retrieves the current state and history of a specific task.
       - [async] get_task_callback(self, request: a2a.types.GetTaskPushNotificationConfigParams, *, context: a2a.client.middleware.ClientCallContext | None = None, extensions: list[str] | None = None) -> a2a.types.TaskPushNotificationConfig
         > Retrieves the push notification configuration for a specific task.
       - resubscribe(self, request: a2a.types.TaskIdParams, *, context: a2a.client.middleware.ClientCallContext | None = None, extensions: list[str] | None = None) -> collections.abc.AsyncIterator[tuple[a2a.types.Task, a2a.types.TaskStatusUpdateEvent | a2a.types.TaskArtifactUpdateEvent | None]]
         > Resubscribes to a task's event stream.
       - send_message(self, request: a2a.types.Message, *, context: a2a.client.middleware.ClientCallContext | None = None, request_metadata: dict[str, typing.Any] | None = None, extensions: list[str] | None = None) -> collections.abc.AsyncIterator[tuple[a2a.types.Task, a2a.types.TaskStatusUpdateEvent | a2a.types.TaskArtifactUpdateEvent | None] | a2a.types.Message]
         > Sends a message to the server.  This will automatically use the streaming or non-streaming approach as supported by the server and the client config. 
       - [async] set_task_callback(self, request: a2a.types.TaskPushNotificationConfig, *, context: a2a.client.middleware.ClientCallContext | None = None, extensions: list[str] | None = None) -> a2a.types.TaskPushNotificationConfig
         > Sets or updates the push notification configuration for a specific task.

  [ClientCallContext]
     Inherits from: BaseModel
     A context passed with each client call, allowing for call-specific.
     configuration and data passing. Such as authentication details or
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [ClientCallInterceptor]
     Inherits from: ABC
     An abstract base class for client-side call interceptors.
     Interceptors can inspect and modify requests before they are sent,
     Constructor: __init__(self, /, *args, **kwargs)
     Methods (1):
       - [async] intercept(self, method_name: 'str', request_payload: 'dict[str, Any]', http_kwargs: 'dict[str, Any]', agent_card: 'AgentCard | None', context: 'ClientCallContext | None') -> 'tuple[dict[str, Any], dict[str, Any]]'
         > Intercepts a client call before the request is sent.  Args:     method_name: The name of the RPC method (e.g., 'message/send').     request_payload: T

  [ClientConfig]
     Configuration class for the A2AClient Factory.
     Constructor: __init__(self, streaming: bool = True, polling: bool = False, httpx_client: httpx.AsyncClient | None = None, grpc_channel_factory: collections.abc.Callable[[str], None] | None = None, supported_transports: list[a2a.types.TransportProtocol | str] = <factory>, use_client_preference: bool = False, accepted_output_modes: list[str] = <factory>, push_notification_configs: list[a2a.types.PushNotificationConfig] = <factory>, extensions: list[str] = <factory>) -> None
     Methods (1):
       - __init__(self, streaming: bool = True, polling: bool = False, httpx_client: httpx.AsyncClient | None = None, grpc_channel_factory: collections.abc.Callable[[str], None] | None = None, supported_transports: list[a2a.types.TransportProtocol | str] = <factory>, use_client_preference: bool = False, accepted_output_modes: list[str] = <factory>, push_notification_configs: list[a2a.types.PushNotificationConfig] = <factory>, extensions: list[str] = <factory>) -> None
         > Initialize self.  See help(type(self)) for accurate signature.
     Attributes (5):
       - grpc_channel_factory: NoneType
       - httpx_client: NoneType
       - polling: bool
       - streaming: bool
       - use_client_preference: bool

  [ClientFactory]
     ClientFactory is used to generate the appropriate client for the agent.
     The factory is configured with a `ClientConfig` and optionally a list of
     Constructor: __init__(self, config: 'ClientConfig', consumers: 'list[Consumer] | None' = None)
     Methods (4):
       - __init__(self, config: 'ClientConfig', consumers: 'list[Consumer] | None' = None)
         > Initialize self.  See help(type(self)) for accurate signature.
       - [async] connect(agent: 'str | AgentCard', client_config: 'ClientConfig | None' = None, consumers: 'list[Consumer] | None' = None, interceptors: 'list[ClientCallInterceptor] | None' = None, relative_card_path: 'str | None' = None, resolver_http_kwargs: 'dict[str, Any] | None' = None, extra_transports: 'dict[str, TransportProducer] | None' = None, extensions: 'list[str] | None' = None) -> 'Client'
         > Convenience method for constructing a client.  Constructs a client that connects to the specified agent. Note that creating multiple clients via this 
       - create(self, card: 'AgentCard', consumers: 'list[Consumer] | None' = None, interceptors: 'list[ClientCallInterceptor] | None' = None, extensions: 'list[str] | None' = None) -> 'Client'
         > Create a new `Client` for the provided `AgentCard`.  Args:   card: An `AgentCard` defining the characteristics of the agent.   consumers: A list of `C
       - register(self, label: 'str', generator: 'TransportProducer') -> 'None'
         > Register a new transport producer for a given transport label.

  [CredentialService]
     Inherits from: ABC
     An abstract service for retrieving credentials.
     Constructor: __init__(self, /, *args, **kwargs)
     Methods (1):
       - [async] get_credentials(self, security_scheme_name: str, context: a2a.client.middleware.ClientCallContext | None) -> str | None
         > Retrieves a credential (e.g., token) for a security scheme.

  [InMemoryContextCredentialStore]
     Inherits from: CredentialService
     A simple in-memory store for session-keyed credentials.
     This class uses the 'sessionId' from the ClientCallContext state to
     Constructor: __init__(self) -> None
     Methods (3):
       - __init__(self) -> None
         > Initialize self.  See help(type(self)) for accurate signature.
       - [async] get_credentials(self, security_scheme_name: str, context: a2a.client.middleware.ClientCallContext | None) -> str | None
         > Retrieves credentials from the in-memory store.  Args:     security_scheme_name: The name of the security scheme.     context: The client call context
       - [async] set_credentials(self, session_id: str, security_scheme_name: str, credential: str) -> None
         > Method to populate the store.

FUNCTIONS (2)
--------------------------------------------------------------------------------
  - create_text_message_object(role: a2a.types.Role = <Role.user: 'user'>, content: str = '') -> a2a.types.Message
    > Create a Message object containing a single TextPart.  Args:     role: The role of the message sender (user or agent). Defaults to Role.user.     cont
  - minimal_agent_card(url: 'str', transports: 'list[str] | None' = None) -> 'AgentCard'
    > Generates a minimal card to simplify bootstrapping client creation.  This minimal card is not viable itself to interact with the remote agent. Instead

================================================================================
MODULE: a2a.server
================================================================================

================================================================================
MODULE: a2a.types
================================================================================

CLASSES (100)
--------------------------------------------------------------------------------

  [A2A]
     Inherits from: RootModel[Any]
     !!! abstract "Usage Documentation"
     [`RootModel` and Custom Root Types](../concepts/models.md#rootmodel-and-custom-root-types)
     Constructor: __init__(self, /, root: 'RootModelRootType' = PydanticUndefined, **data) -> 'None'
     Methods (24):
       - __init__(self, /, root: 'RootModelRootType' = PydanticUndefined, **data) -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(root: 'RootModelRootType', _fields_set: 'set[str] | None' = None) -> 'Self'
         > Create a new model using the provided root object and update fields set.  Args:     root: The root object of the model.     _fields_set: The set of fi
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [A2ABaseModel]
     Inherits from: BaseModel
     Base class for shared behavior across A2A data models.
     Provides a common configuration (e.g., alias-based population) and
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [A2AError]
     Inherits from: RootModel[Union[JSONParseError, InvalidRequestError, MethodNotFoundError, InvalidParamsError, InternalError, TaskNotFoundError, TaskNotCancelableError, PushNotificationNotSupportedError, UnsupportedOperationError, ContentTypeNotSupportedError, InvalidAgentResponseError, AuthenticatedExtendedCardNotConfiguredError]]
     !!! abstract "Usage Documentation"
     [`RootModel` and Custom Root Types](../concepts/models.md#rootmodel-and-custom-root-types)
     Constructor: __init__(self, /, root: 'RootModelRootType' = PydanticUndefined, **data) -> 'None'
     Methods (24):
       - __init__(self, /, root: 'RootModelRootType' = PydanticUndefined, **data) -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(root: 'RootModelRootType', _fields_set: 'set[str] | None' = None) -> 'Self'
         > Create a new model using the provided root object and update fields set.  Args:     root: The root object of the model.     _fields_set: The set of fi
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [A2ARequest]
     Inherits from: RootModel[Union[SendMessageRequest, SendStreamingMessageRequest, GetTaskRequest, CancelTaskRequest, SetTaskPushNotificationConfigRequest, GetTaskPushNotificationConfigRequest, TaskResubscriptionRequest, ListTaskPushNotificationConfigRequest, DeleteTaskPushNotificationConfigRequest, GetAuthenticatedExtendedCardRequest]]
     !!! abstract "Usage Documentation"
     [`RootModel` and Custom Root Types](../concepts/models.md#rootmodel-and-custom-root-types)
     Constructor: __init__(self, /, root: 'RootModelRootType' = PydanticUndefined, **data) -> 'None'
     Methods (24):
       - __init__(self, /, root: 'RootModelRootType' = PydanticUndefined, **data) -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(root: 'RootModelRootType', _fields_set: 'set[str] | None' = None) -> 'Self'
         > Create a new model using the provided root object and update fields set.  Args:     root: The root object of the model.     _fields_set: The set of fi
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [APIKeySecurityScheme]
     Inherits from: A2ABaseModel
     Defines a security scheme using an API key.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [AgentCapabilities]
     Inherits from: A2ABaseModel
     Defines optional capabilities supported by an agent.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [AgentCard]
     Inherits from: A2ABaseModel
     The AgentCard is a self-describing manifest for an agent. It provides essential
     metadata including the agent's identity, capabilities, skills, supported
     communication methods, and security requirements.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [AgentCardSignature]
     Inherits from: A2ABaseModel
     AgentCardSignature represents a JWS signature of an AgentCard.
     This follows the JSON format of an RFC 7515 JSON Web Signature (JWS).
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [AgentExtension]
     Inherits from: A2ABaseModel
     A declaration of a protocol extension supported by an Agent.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [AgentInterface]
     Inherits from: A2ABaseModel
     Declares a combination of a target URL and a transport protocol for interacting with the agent.
     This allows agents to expose the same functionality over multiple transport mechanisms.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [AgentProvider]
     Inherits from: A2ABaseModel
     Represents the service provider of an agent.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [AgentSkill]
     Inherits from: A2ABaseModel
     Represents a distinct capability or function that an agent can perform.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [Any]
     Special type indicating an unconstrained type.
     - Any is compatible with every type.
     Constructor: __init__(self, /, *args, **kwargs)

  [Artifact]
     Inherits from: A2ABaseModel
     Represents a file, data structure, or other resource generated by an agent during a task.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [AuthenticatedExtendedCardNotConfiguredError]
     Inherits from: A2ABaseModel
     An A2A-specific error indicating that the agent does not have an Authenticated Extended Card configured
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [AuthorizationCodeOAuthFlow]
     Inherits from: A2ABaseModel
     Defines configuration details for the OAuth 2.0 Authorization Code flow.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [CancelTaskRequest]
     Inherits from: A2ABaseModel
     Represents a JSON-RPC request for the `tasks/cancel` method.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [CancelTaskResponse]
     Inherits from: RootModel[Union[JSONRPCErrorResponse, CancelTaskSuccessResponse]]
     !!! abstract "Usage Documentation"
     [`RootModel` and Custom Root Types](../concepts/models.md#rootmodel-and-custom-root-types)
     Constructor: __init__(self, /, root: 'RootModelRootType' = PydanticUndefined, **data) -> 'None'
     Methods (24):
       - __init__(self, /, root: 'RootModelRootType' = PydanticUndefined, **data) -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(root: 'RootModelRootType', _fields_set: 'set[str] | None' = None) -> 'Self'
         > Create a new model using the provided root object and update fields set.  Args:     root: The root object of the model.     _fields_set: The set of fi
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [CancelTaskSuccessResponse]
     Inherits from: A2ABaseModel
     Represents a successful JSON-RPC response for the `tasks/cancel` method.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [ClientCredentialsOAuthFlow]
     Inherits from: A2ABaseModel
     Defines configuration details for the OAuth 2.0 Client Credentials flow.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [ContentTypeNotSupportedError]
     Inherits from: A2ABaseModel
     An A2A-specific error indicating an incompatibility between the requested
     content types and the agent's capabilities.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [DataPart]
     Inherits from: A2ABaseModel
     Represents a structured data segment (e.g., JSON) within a message or artifact.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [DeleteTaskPushNotificationConfigParams]
     Inherits from: A2ABaseModel
     Defines parameters for deleting a specific push notification configuration for a task.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [DeleteTaskPushNotificationConfigRequest]
     Inherits from: A2ABaseModel
     Represents a JSON-RPC request for the `tasks/pushNotificationConfig/delete` method.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [DeleteTaskPushNotificationConfigResponse]
     Inherits from: RootModel[Union[JSONRPCErrorResponse, DeleteTaskPushNotificationConfigSuccessResponse]]
     !!! abstract "Usage Documentation"
     [`RootModel` and Custom Root Types](../concepts/models.md#rootmodel-and-custom-root-types)
     Constructor: __init__(self, /, root: 'RootModelRootType' = PydanticUndefined, **data) -> 'None'
     Methods (24):
       - __init__(self, /, root: 'RootModelRootType' = PydanticUndefined, **data) -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(root: 'RootModelRootType', _fields_set: 'set[str] | None' = None) -> 'Self'
         > Create a new model using the provided root object and update fields set.  Args:     root: The root object of the model.     _fields_set: The set of fi
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [DeleteTaskPushNotificationConfigSuccessResponse]
     Inherits from: A2ABaseModel
     Represents a successful JSON-RPC response for the `tasks/pushNotificationConfig/delete` method.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [Enum]
     Create a collection of name/value pairs.
     Example enumeration:
     Constructor: __init__(self, *args, **kwds)

  [FileBase]
     Inherits from: A2ABaseModel
     Defines base properties for a file.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [FilePart]
     Inherits from: A2ABaseModel
     Represents a file segment within a message or artifact. The file content can be
     provided either directly as bytes or as a URI.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [FileWithBytes]
     Inherits from: A2ABaseModel
     Represents a file with its content provided directly as a base64-encoded string.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [FileWithUri]
     Inherits from: A2ABaseModel
     Represents a file with its content located at a specific URI.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [GetAuthenticatedExtendedCardRequest]
     Inherits from: A2ABaseModel
     Represents a JSON-RPC request for the `agent/getAuthenticatedExtendedCard` method.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [GetAuthenticatedExtendedCardResponse]
     Inherits from: RootModel[Union[JSONRPCErrorResponse, GetAuthenticatedExtendedCardSuccessResponse]]
     !!! abstract "Usage Documentation"
     [`RootModel` and Custom Root Types](../concepts/models.md#rootmodel-and-custom-root-types)
     Constructor: __init__(self, /, root: 'RootModelRootType' = PydanticUndefined, **data) -> 'None'
     Methods (24):
       - __init__(self, /, root: 'RootModelRootType' = PydanticUndefined, **data) -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(root: 'RootModelRootType', _fields_set: 'set[str] | None' = None) -> 'Self'
         > Create a new model using the provided root object and update fields set.  Args:     root: The root object of the model.     _fields_set: The set of fi
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [GetAuthenticatedExtendedCardSuccessResponse]
     Inherits from: A2ABaseModel
     Represents a successful JSON-RPC response for the `agent/getAuthenticatedExtendedCard` method.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [GetTaskPushNotificationConfigParams]
     Inherits from: A2ABaseModel
     Defines parameters for fetching a specific push notification configuration for a task.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [GetTaskPushNotificationConfigRequest]
     Inherits from: A2ABaseModel
     Represents a JSON-RPC request for the `tasks/pushNotificationConfig/get` method.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [GetTaskPushNotificationConfigResponse]
     Inherits from: RootModel[Union[JSONRPCErrorResponse, GetTaskPushNotificationConfigSuccessResponse]]
     !!! abstract "Usage Documentation"
     [`RootModel` and Custom Root Types](../concepts/models.md#rootmodel-and-custom-root-types)
     Constructor: __init__(self, /, root: 'RootModelRootType' = PydanticUndefined, **data) -> 'None'
     Methods (24):
       - __init__(self, /, root: 'RootModelRootType' = PydanticUndefined, **data) -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(root: 'RootModelRootType', _fields_set: 'set[str] | None' = None) -> 'Self'
         > Create a new model using the provided root object and update fields set.  Args:     root: The root object of the model.     _fields_set: The set of fi
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [GetTaskPushNotificationConfigSuccessResponse]
     Inherits from: A2ABaseModel
     Represents a successful JSON-RPC response for the `tasks/pushNotificationConfig/get` method.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [GetTaskRequest]
     Inherits from: A2ABaseModel
     Represents a JSON-RPC request for the `tasks/get` method.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [GetTaskResponse]
     Inherits from: RootModel[Union[JSONRPCErrorResponse, GetTaskSuccessResponse]]
     !!! abstract "Usage Documentation"
     [`RootModel` and Custom Root Types](../concepts/models.md#rootmodel-and-custom-root-types)
     Constructor: __init__(self, /, root: 'RootModelRootType' = PydanticUndefined, **data) -> 'None'
     Methods (24):
       - __init__(self, /, root: 'RootModelRootType' = PydanticUndefined, **data) -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(root: 'RootModelRootType', _fields_set: 'set[str] | None' = None) -> 'Self'
         > Create a new model using the provided root object and update fields set.  Args:     root: The root object of the model.     _fields_set: The set of fi
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [GetTaskSuccessResponse]
     Inherits from: A2ABaseModel
     Represents a successful JSON-RPC response for the `tasks/get` method.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [HTTPAuthSecurityScheme]
     Inherits from: A2ABaseModel
     Defines a security scheme using HTTP authentication.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [ImplicitOAuthFlow]
     Inherits from: A2ABaseModel
     Defines configuration details for the OAuth 2.0 Implicit flow.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [In]
     Inherits from: str, Enum
     The location of the API key.
     Constructor: __init__(self, *args, **kwds)
     Methods (1):
       - __init__(self, *args, **kwds)
         > Initialize self.  See help(type(self)) for accurate signature.
     Attributes (5):
       - cookie: In
       - header: In
       - name: property
       - query: In
       - value: property

  [InternalError]
     Inherits from: A2ABaseModel
     An error indicating an internal error on the server.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [InvalidAgentResponseError]
     Inherits from: A2ABaseModel
     An A2A-specific error indicating that the agent returned a response that
     does not conform to the specification for the current method.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [InvalidParamsError]
     Inherits from: A2ABaseModel
     An error indicating that the method parameters are invalid.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [InvalidRequestError]
     Inherits from: A2ABaseModel
     An error indicating that the JSON sent is not a valid Request object.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [JSONParseError]
     Inherits from: A2ABaseModel
     An error indicating that the server received invalid JSON.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [JSONRPCError]
     Inherits from: A2ABaseModel
     Represents a JSON-RPC 2.0 Error object, included in an error response.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [JSONRPCErrorResponse]
     Inherits from: A2ABaseModel
     Represents a JSON-RPC 2.0 Error Response object.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [JSONRPCMessage]
     Inherits from: A2ABaseModel
     Defines the base structure for any JSON-RPC 2.0 request, response, or notification.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [JSONRPCRequest]
     Inherits from: A2ABaseModel
     Represents a JSON-RPC 2.0 Request object.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [JSONRPCResponse]
     Inherits from: RootModel[Union[JSONRPCErrorResponse, SendMessageSuccessResponse, SendStreamingMessageSuccessResponse, GetTaskSuccessResponse, CancelTaskSuccessResponse, SetTaskPushNotificationConfigSuccessResponse, GetTaskPushNotificationConfigSuccessResponse, ListTaskPushNotificationConfigSuccessResponse, DeleteTaskPushNotificationConfigSuccessResponse, GetAuthenticatedExtendedCardSuccessResponse]]
     !!! abstract "Usage Documentation"
     [`RootModel` and Custom Root Types](../concepts/models.md#rootmodel-and-custom-root-types)
     Constructor: __init__(self, /, root: 'RootModelRootType' = PydanticUndefined, **data) -> 'None'
     Methods (24):
       - __init__(self, /, root: 'RootModelRootType' = PydanticUndefined, **data) -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(root: 'RootModelRootType', _fields_set: 'set[str] | None' = None) -> 'Self'
         > Create a new model using the provided root object and update fields set.  Args:     root: The root object of the model.     _fields_set: The set of fi
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [JSONRPCSuccessResponse]
     Inherits from: A2ABaseModel
     Represents a successful JSON-RPC 2.0 Response object.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [ListTaskPushNotificationConfigParams]
     Inherits from: A2ABaseModel
     Defines parameters for listing all push notification configurations associated with a task.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [ListTaskPushNotificationConfigRequest]
     Inherits from: A2ABaseModel
     Represents a JSON-RPC request for the `tasks/pushNotificationConfig/list` method.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [ListTaskPushNotificationConfigResponse]
     Inherits from: RootModel[Union[JSONRPCErrorResponse, ListTaskPushNotificationConfigSuccessResponse]]
     !!! abstract "Usage Documentation"
     [`RootModel` and Custom Root Types](../concepts/models.md#rootmodel-and-custom-root-types)
     Constructor: __init__(self, /, root: 'RootModelRootType' = PydanticUndefined, **data) -> 'None'
     Methods (24):
       - __init__(self, /, root: 'RootModelRootType' = PydanticUndefined, **data) -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(root: 'RootModelRootType', _fields_set: 'set[str] | None' = None) -> 'Self'
         > Create a new model using the provided root object and update fields set.  Args:     root: The root object of the model.     _fields_set: The set of fi
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [ListTaskPushNotificationConfigSuccessResponse]
     Inherits from: A2ABaseModel
     Represents a successful JSON-RPC response for the `tasks/pushNotificationConfig/list` method.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [Message]
     Inherits from: A2ABaseModel
     Represents a single message in the conversation between a user and an agent.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [MessageSendConfiguration]
     Inherits from: A2ABaseModel
     Defines configuration options for a `message/send` or `message/stream` request.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [MessageSendParams]
     Inherits from: A2ABaseModel
     Defines the parameters for a request to send a message to an agent. This can be used
     to create a new task, continue an existing one, or restart a task.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [MethodNotFoundError]
     Inherits from: A2ABaseModel
     An error indicating that the requested method does not exist or is not available.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [MutualTLSSecurityScheme]
     Inherits from: A2ABaseModel
     Defines a security scheme using mTLS authentication.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [OAuth2SecurityScheme]
     Inherits from: A2ABaseModel
     Defines a security scheme using OAuth 2.0.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [OAuthFlows]
     Inherits from: A2ABaseModel
     Defines the configuration for the supported OAuth 2.0 flows.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [OpenIdConnectSecurityScheme]
     Inherits from: A2ABaseModel
     Defines a security scheme using OpenID Connect.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [Part]
     Inherits from: RootModel[Union[TextPart, FilePart, DataPart]]
     !!! abstract "Usage Documentation"
     [`RootModel` and Custom Root Types](../concepts/models.md#rootmodel-and-custom-root-types)
     Constructor: __init__(self, /, root: 'RootModelRootType' = PydanticUndefined, **data) -> 'None'
     Methods (24):
       - __init__(self, /, root: 'RootModelRootType' = PydanticUndefined, **data) -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(root: 'RootModelRootType', _fields_set: 'set[str] | None' = None) -> 'Self'
         > Create a new model using the provided root object and update fields set.  Args:     root: The root object of the model.     _fields_set: The set of fi
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [PartBase]
     Inherits from: A2ABaseModel
     Defines base properties common to all message or artifact parts.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [PasswordOAuthFlow]
     Inherits from: A2ABaseModel
     Defines configuration details for the OAuth 2.0 Resource Owner Password flow.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [PushNotificationAuthenticationInfo]
     Inherits from: A2ABaseModel
     Defines authentication details for a push notification endpoint.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [PushNotificationConfig]
     Inherits from: A2ABaseModel
     Defines the configuration for setting up push notifications for task updates.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [PushNotificationNotSupportedError]
     Inherits from: A2ABaseModel
     An A2A-specific error indicating that the agent does not support push notifications.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [Role]
     Inherits from: str, Enum
     Identifies the sender of the message. `user` for the client, `agent` for the service.
     Constructor: __init__(self, *args, **kwds)
     Methods (1):
       - __init__(self, *args, **kwds)
         > Initialize self.  See help(type(self)) for accurate signature.
     Attributes (4):
       - agent: Role
       - name: property
       - user: Role
       - value: property

  [RootModel]
     Inherits from: BaseModel, Generic
     !!! abstract "Usage Documentation"
     [`RootModel` and Custom Root Types](../concepts/models.md#rootmodel-and-custom-root-types)
     Constructor: __init__(self, /, root: 'RootModelRootType' = PydanticUndefined, **data) -> 'None'
     Methods (24):
       - __init__(self, /, root: 'RootModelRootType' = PydanticUndefined, **data) -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(root: 'RootModelRootType', _fields_set: 'set[str] | None' = None) -> 'Self'
         > Create a new model using the provided root object and update fields set.  Args:     root: The root object of the model.     _fields_set: The set of fi
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [SecurityScheme]
     Inherits from: RootModel[Union[APIKeySecurityScheme, HTTPAuthSecurityScheme, OAuth2SecurityScheme, OpenIdConnectSecurityScheme, MutualTLSSecurityScheme]]
     !!! abstract "Usage Documentation"
     [`RootModel` and Custom Root Types](../concepts/models.md#rootmodel-and-custom-root-types)
     Constructor: __init__(self, /, root: 'RootModelRootType' = PydanticUndefined, **data) -> 'None'
     Methods (24):
       - __init__(self, /, root: 'RootModelRootType' = PydanticUndefined, **data) -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(root: 'RootModelRootType', _fields_set: 'set[str] | None' = None) -> 'Self'
         > Create a new model using the provided root object and update fields set.  Args:     root: The root object of the model.     _fields_set: The set of fi
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [SecuritySchemeBase]
     Inherits from: A2ABaseModel
     Defines base properties shared by all security scheme objects.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [SendMessageRequest]
     Inherits from: A2ABaseModel
     Represents a JSON-RPC request for the `message/send` method.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [SendMessageResponse]
     Inherits from: RootModel[Union[JSONRPCErrorResponse, SendMessageSuccessResponse]]
     !!! abstract "Usage Documentation"
     [`RootModel` and Custom Root Types](../concepts/models.md#rootmodel-and-custom-root-types)
     Constructor: __init__(self, /, root: 'RootModelRootType' = PydanticUndefined, **data) -> 'None'
     Methods (24):
       - __init__(self, /, root: 'RootModelRootType' = PydanticUndefined, **data) -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(root: 'RootModelRootType', _fields_set: 'set[str] | None' = None) -> 'Self'
         > Create a new model using the provided root object and update fields set.  Args:     root: The root object of the model.     _fields_set: The set of fi
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [SendMessageSuccessResponse]
     Inherits from: A2ABaseModel
     Represents a successful JSON-RPC response for the `message/send` method.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [SendStreamingMessageRequest]
     Inherits from: A2ABaseModel
     Represents a JSON-RPC request for the `message/stream` method.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [SendStreamingMessageResponse]
     Inherits from: RootModel[Union[JSONRPCErrorResponse, SendStreamingMessageSuccessResponse]]
     !!! abstract "Usage Documentation"
     [`RootModel` and Custom Root Types](../concepts/models.md#rootmodel-and-custom-root-types)
     Constructor: __init__(self, /, root: 'RootModelRootType' = PydanticUndefined, **data) -> 'None'
     Methods (24):
       - __init__(self, /, root: 'RootModelRootType' = PydanticUndefined, **data) -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(root: 'RootModelRootType', _fields_set: 'set[str] | None' = None) -> 'Self'
         > Create a new model using the provided root object and update fields set.  Args:     root: The root object of the model.     _fields_set: The set of fi
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [SendStreamingMessageSuccessResponse]
     Inherits from: A2ABaseModel
     Represents a successful JSON-RPC response for the `message/stream` method.
     The server may send multiple response objects for a single request.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [SetTaskPushNotificationConfigRequest]
     Inherits from: A2ABaseModel
     Represents a JSON-RPC request for the `tasks/pushNotificationConfig/set` method.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [SetTaskPushNotificationConfigResponse]
     Inherits from: RootModel[Union[JSONRPCErrorResponse, SetTaskPushNotificationConfigSuccessResponse]]
     !!! abstract "Usage Documentation"
     [`RootModel` and Custom Root Types](../concepts/models.md#rootmodel-and-custom-root-types)
     Constructor: __init__(self, /, root: 'RootModelRootType' = PydanticUndefined, **data) -> 'None'
     Methods (24):
       - __init__(self, /, root: 'RootModelRootType' = PydanticUndefined, **data) -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(root: 'RootModelRootType', _fields_set: 'set[str] | None' = None) -> 'Self'
         > Create a new model using the provided root object and update fields set.  Args:     root: The root object of the model.     _fields_set: The set of fi
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [SetTaskPushNotificationConfigSuccessResponse]
     Inherits from: A2ABaseModel
     Represents a successful JSON-RPC response for the `tasks/pushNotificationConfig/set` method.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [Task]
     Inherits from: A2ABaseModel
     Represents a single, stateful operation or conversation between a client and an agent.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [TaskArtifactUpdateEvent]
     Inherits from: A2ABaseModel
     An event sent by the agent to notify the client that an artifact has been
     generated or updated. This is typically used in streaming models.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [TaskIdParams]
     Inherits from: A2ABaseModel
     Defines parameters containing a task ID, used for simple task operations.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [TaskNotCancelableError]
     Inherits from: A2ABaseModel
     An A2A-specific error indicating that the task is in a state where it cannot be canceled.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [TaskNotFoundError]
     Inherits from: A2ABaseModel
     An A2A-specific error indicating that the requested task ID was not found.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [TaskPushNotificationConfig]
     Inherits from: A2ABaseModel
     A container associating a push notification configuration with a specific task.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [TaskQueryParams]
     Inherits from: A2ABaseModel
     Defines parameters for querying a task, with an option to limit history length.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [TaskResubscriptionRequest]
     Inherits from: A2ABaseModel
     Represents a JSON-RPC request for the `tasks/resubscribe` method, used to resume a streaming connection.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [TaskState]
     Inherits from: str, Enum
     Defines the lifecycle states of a Task.
     Constructor: __init__(self, *args, **kwds)
     Methods (1):
       - __init__(self, *args, **kwds)
         > Initialize self.  See help(type(self)) for accurate signature.
     Attributes (11):
       - auth_required: TaskState
       - canceled: TaskState
       - completed: TaskState
       - failed: TaskState
       - input_required: TaskState
       - name: property
       - rejected: TaskState
       - submitted: TaskState
       - unknown: TaskState
       - value: property
       - working: TaskState

  [TaskStatus]
     Inherits from: A2ABaseModel
     Represents the status of a task at a specific point in time.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [TaskStatusUpdateEvent]
     Inherits from: A2ABaseModel
     An event sent by the agent to notify the client of a change in a task's status.
     This is typically used in streaming or subscription models.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [TextPart]
     Inherits from: A2ABaseModel
     Represents a text segment within a message or artifact.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

  [TransportProtocol]
     Inherits from: str, Enum
     Supported A2A transport protocols.
     Constructor: __init__(self, *args, **kwds)
     Methods (1):
       - __init__(self, *args, **kwds)
         > Initialize self.  See help(type(self)) for accurate signature.
     Attributes (5):
       - grpc: TransportProtocol
       - http_json: TransportProtocol
       - jsonrpc: TransportProtocol
       - name: property
       - value: property

  [UnsupportedOperationError]
     Inherits from: A2ABaseModel
     An A2A-specific error indicating that the requested operation is not supported by the agent.
     Constructor: __init__(self, /, **data: 'Any') -> 'None'
     Methods (24):
       - __init__(self, /, **data: 'Any') -> 'None'
         > Create a new model by parsing and validating input data from keyword arguments.  Raises [`ValidationError`][pydantic_core.ValidationError] if the inpu
       - construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
       - copy(self, *, include: 'AbstractSetIntStr | MappingIntStrAny | None' = None, exclude: 'AbstractSetIntStr | MappingIntStrAny | None' = None, update: 'Dict[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > Returns a copy of the model.  !!! warning "Deprecated"     This method is now deprecated; use `model_copy` instead.  If you need `include` or `exclude
       - dict(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False) -> 'Dict[str, Any]'
       - from_orm(obj: 'Any') -> 'Self'
       - json(self, *, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, by_alias: 'bool' = False, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, encoder: 'Callable[[Any], Any] | None' = PydanticUndefined, models_as_dict: 'bool' = PydanticUndefined, **dumps_kwargs: 'Any') -> 'str'
       - model_construct(_fields_set: 'set[str] | None' = None, **values: 'Any') -> 'Self'
         > Creates a new instance of the `Model` class with validated data.  Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or
       - model_copy(self, *, update: 'Mapping[str, Any] | None' = None, deep: 'bool' = False) -> 'Self'
         > !!! abstract "Usage Documentation"     [`model_copy`](../concepts/models.md#model-copy)  Returns a copy of the model.  !!! note     The underlying ins
       - model_dump(self, *, mode: "Literal['json', 'python'] | str" = 'python', include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'dict[str, Any]'
         > !!! abstract "Usage Documentation"     [`model_dump`](../concepts/serialization.md#python-mode)  Generate a dictionary representation of the model, op
       - model_dump_json(self, *, indent: 'int | None' = None, ensure_ascii: 'bool' = False, include: 'IncEx | None' = None, exclude: 'IncEx | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, exclude_unset: 'bool' = False, exclude_defaults: 'bool' = False, exclude_none: 'bool' = False, exclude_computed_fields: 'bool' = False, round_trip: 'bool' = False, warnings: "bool | Literal['none', 'warn', 'error']" = True, fallback: 'Callable[[Any], Any] | None' = None, serialize_as_any: 'bool' = False) -> 'str'
         > !!! abstract "Usage Documentation"     [`model_dump_json`](../concepts/serialization.md#json-mode)  Generates a JSON representation of the model using
       - model_json_schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', schema_generator: 'type[GenerateJsonSchema]' = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: 'JsonSchemaMode' = 'validation', *, union_format: "Literal['any_of', 'primitive_type_array']" = 'any_of') -> 'dict[str, Any]'
         > Generates a JSON schema for a model class.  Args:     by_alias: Whether to use attribute aliases or not.     ref_template: The reference template.    
       - model_parametrized_name(params: 'tuple[type[Any], ...]') -> 'str'
         > Compute the class name for parametrizations of generic classes.  This method can be overridden to achieve a custom naming scheme for generic BaseModel
       - model_post_init(self, context: 'Any', /) -> 'None'
         > Override this method to perform additional initialization after `__init__` and `model_construct`. This is useful if you want to do some validation tha
       - model_rebuild(*, force: 'bool' = False, raise_errors: 'bool' = True, _parent_namespace_depth: 'int' = 2, _types_namespace: 'MappingNamespace | None' = None) -> 'bool | None'
         > Try to rebuild the pydantic-core schema for the model.  This may be necessary when one of the annotations is a ForwardRef which could not be resolved 
       - model_validate(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, from_attributes: 'bool | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate a pydantic model instance.  Args:     obj: The object to validate.     strict: Whether to enforce types strictly.     extra: Whether to ignor
       - model_validate_json(json_data: 'str | bytes | bytearray', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > !!! abstract "Usage Documentation"     [JSON Parsing](../concepts/json.md#json-parsing)  Validate the given JSON data against the Pydantic model.  Arg
       - model_validate_strings(obj: 'Any', *, strict: 'bool | None' = None, extra: 'ExtraValues | None' = None, context: 'Any | None' = None, by_alias: 'bool | None' = None, by_name: 'bool | None' = None) -> 'Self'
         > Validate the given object with string data against the Pydantic model.  Args:     obj: The object containing string data to validate.     strict: Whet
       - parse_file(path: 'str | Path', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - parse_obj(obj: 'Any') -> 'Self'
       - parse_raw(b: 'str | bytes', *, content_type: 'str | None' = None, encoding: 'str' = 'utf8', proto: 'DeprecatedParseProtocol | None' = None, allow_pickle: 'bool' = False) -> 'Self'
       - schema(by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}') -> 'Dict[str, Any]'
       - schema_json(*, by_alias: 'bool' = True, ref_template: 'str' = '#/$defs/{model}', **dumps_kwargs: 'Any') -> 'str'
       - update_forward_refs(**localns: 'Any') -> 'None'
       - validate(value: 'Any') -> 'Self'
     Attributes (5):
       - model_computed_fields: dict
       - model_config: dict
       - model_extra: property
       - model_fields: dict
       - model_fields_set: property

FUNCTIONS (1)
--------------------------------------------------------------------------------
  - Field(default: 'Any' = PydanticUndefined, *, default_factory: 'Callable[[], Any] | Callable[[dict[str, Any]], Any] | None' = PydanticUndefined, alias: 'str | None' = PydanticUndefined, alias_priority: 'int | None' = PydanticUndefined, validation_alias: 'str | AliasPath | AliasChoices | None' = PydanticUndefined, serialization_alias: 'str | None' = PydanticUndefined, title: 'str | None' = PydanticUndefined, field_title_generator: 'Callable[[str, FieldInfo], str] | None' = PydanticUndefined, description: 'str | None' = PydanticUndefined, examples: 'list[Any] | None' = PydanticUndefined, exclude: 'bool | None' = PydanticUndefined, exclude_if: 'Callable[[Any], bool] | None' = PydanticUndefined, discriminator: 'str | types.Discriminator | None' = PydanticUndefined, deprecated: 'Deprecated | str | bool | None' = PydanticUndefined, json_schema_extra: 'JsonDict | Callable[[JsonDict], None] | None' = PydanticUndefined, frozen: 'bool | None' = PydanticUndefined, validate_default: 'bool | None' = PydanticUndefined, repr: 'bool' = PydanticUndefined, init: 'bool | None' = PydanticUndefined, init_var: 'bool | None' = PydanticUndefined, kw_only: 'bool | None' = PydanticUndefined, pattern: 'str | re.Pattern[str] | None' = PydanticUndefined, strict: 'bool | None' = PydanticUndefined, coerce_numbers_to_str: 'bool | None' = PydanticUndefined, gt: 'annotated_types.SupportsGt | None' = PydanticUndefined, ge: 'annotated_types.SupportsGe | None' = PydanticUndefined, lt: 'annotated_types.SupportsLt | None' = PydanticUndefined, le: 'annotated_types.SupportsLe | None' = PydanticUndefined, multiple_of: 'float | None' = PydanticUndefined, allow_inf_nan: 'bool | None' = PydanticUndefined, max_digits: 'int | None' = PydanticUndefined, decimal_places: 'int | None' = PydanticUndefined, min_length: 'int | None' = PydanticUndefined, max_length: 'int | None' = PydanticUndefined, union_mode: "Literal['smart', 'left_to_right']" = PydanticUndefined, fail_fast: 'bool | None' = PydanticUndefined, **extra: 'Unpack[_EmptyKwargs]') -> 'Any'
    > !!! abstract "Usage Documentation"     [Fields](../concepts/fields.md)  Create a field for objects that can be configured.  Used to provide extra info

================================================================================
MODULE: a2a.utils
================================================================================

FUNCTIONS (16)
--------------------------------------------------------------------------------
  - append_artifact_to_task(task: a2a.types.Task, event: a2a.types.TaskArtifactUpdateEvent) -> None
    > Helper method for updating a Task object with new artifact data from an event.  Handles creating the artifacts list if it doesn't exist, adding new ar
  - are_modalities_compatible(server_output_modes: list[str] | None, client_output_modes: list[str] | None) -> bool
    > Checks if server and client output modalities (MIME types) are compatible.  Modalities are compatible if: 1. The client specifies no preferred output 
  - build_text_artifact(text: str, artifact_id: str) -> a2a.types.Artifact
    > Helper to create a text artifact.  Args:     text: The text content for the artifact.     artifact_id: The ID for the artifact.  Returns:     An `Arti
  - completed_task(task_id: str, context_id: str, artifacts: list[a2a.types.Artifact], history: list[a2a.types.Message] | None = None) -> a2a.types.Task
    > Creates a Task object in the 'completed' state.  Useful for constructing a final Task representation when the agent finishes and produces artifacts.  
  - create_task_obj(message_send_params: a2a.types.MessageSendParams) -> a2a.types.Task
    > Create a new task object from message send params.  Generates UUIDs for task and context IDs if they are not already present in the message.  Args:   
  - get_artifact_text(artifact: a2a.types.Artifact, delimiter: str = '\n') -> str
    > Extracts and joins all text content from an Artifact's parts.  Args:     artifact: The `Artifact` object.     delimiter: The string to use when joinin
  - get_data_parts(parts: list[a2a.types.Part]) -> list[dict[str, typing.Any]]
    > Extracts dictionary data from all DataPart objects in a list of Parts.  Args:     parts: A list of `Part` objects.  Returns:     A list of dictionarie
  - get_file_parts(parts: list[a2a.types.Part]) -> list[a2a.types.FileWithBytes | a2a.types.FileWithUri]
    > Extracts file data from all FilePart objects in a list of Parts.  Args:     parts: A list of `Part` objects.  Returns:     A list of `FileWithBytes` o
  - get_message_text(message: a2a.types.Message, delimiter: str = '\n') -> str
    > Extracts and joins all text content from a Message's parts.  Args:     message: The `Message` object.     delimiter: The string to use when joining te
  - get_text_parts(parts: list[a2a.types.Part]) -> list[str]
    > Extracts text content from all TextPart objects in a list of Parts.  Args:     parts: A list of `Part` objects.  Returns:     A list of strings contai
  - new_agent_parts_message(parts: list[a2a.types.Part], context_id: str | None = None, task_id: str | None = None) -> a2a.types.Message
    > Creates a new agent message containing a list of Parts.  Args:     parts: The list of `Part` objects for the message content.     context_id: The cont
  - new_agent_text_message(text: str, context_id: str | None = None, task_id: str | None = None) -> a2a.types.Message
    > Creates a new agent message containing a single TextPart.  Args:     text: The text content of the message.     context_id: The context ID for the mes
  - new_artifact(parts: list[a2a.types.Part], name: str, description: str | None = None) -> a2a.types.Artifact
    > Creates a new Artifact object.  Args:     parts: The list of `Part` objects forming the artifact's content.     name: The human-readable name of the a
  - new_data_artifact(name: str, data: dict[str, typing.Any], description: str | None = None) -> a2a.types.Artifact
    > Creates a new Artifact object containing only a single DataPart.  Args:     name: The human-readable name of the artifact.     data: The structured da
  - new_task(request: a2a.types.Message) -> a2a.types.Task
    > Creates a new Task object from an initial user message.  Generates task and context IDs if not provided in the message.  Args:     request: The initia
  - new_text_artifact(name: str, text: str, description: str | None = None) -> a2a.types.Artifact
    > Creates a new Artifact object containing only a single TextPart.  Args:     name: The human-readable name of the artifact.     text: The text content 

================================================================================
MODULE: a2a.extensions
================================================================================

================================================================================
MODULE: a2a.grpc
================================================================================

================================================================================
EXPLORATION COMPLETE
================================================================================
